"""
FMOD Project Management Module
Handles FMOD Studio project XML manipulation and metadata management.
"""

import os
import json
import uuid
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from xml.dom import minidom
import wave


class FMODProject:
    """Represents a FMOD Studio project and handles XML manipulation"""

    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
        self.metadata_path = self.project_path.parent / "Metadata"

        # Cache file path (generated by FMOD Studio script)
        self.cache_path = self.project_path.parent / (self.project_path.stem + '_events_cache.json')
        self._cache_data = None
        self._cache_loaded = False

        if not self.metadata_path.exists():
            raise ValueError(f"Metadata folder not found: {self.metadata_path}")

        # Try to load from cache first, otherwise use XML
        if self.cache_path.exists():
            self._load_from_cache()
        else:
            # Load only minimal data needed for UI at startup
            self.workspace = self._load_workspace()
            self.event_folders = self._load_event_folders()

        # OPTIMIZATION: Lazy load everything else
        self._banks = None
        self._buses = None
        self._asset_folders = None
        self._events_by_folder = None

        # Pending folders (not yet written to XML)
        self._pending_event_folders = {}
        self._pending_asset_folders = {}

    def _load_from_cache(self):
        """Load project data from JSON cache (generated by FMOD Studio script)"""
        try:
            with open(self.cache_path, 'r', encoding='utf-8') as f:
                self._cache_data = json.load(f)
            self._cache_loaded = True

            # Load workspace first
            self.workspace = self._load_workspace()

            # Build event_folders from cache
            self.event_folders = {}
            for folder in self._cache_data.get('folders', []):
                self.event_folders[folder['id']] = {
                    'name': folder['name'],
                    'parent': folder['parent'],
                    'path': None,
                    'items': []
                }

            # FALLBACK: If master folder is missing from cache, add it from workspace
            master_id = self.workspace.get('masterEventFolder')
            if master_id and master_id not in self.event_folders:
                # Load master folder from XML
                print(f"Warning: Master folder {master_id} not in cache, loading from XML...")
                xml_folders = self._load_event_folders()
                if master_id in xml_folders:
                    self.event_folders[master_id] = xml_folders[master_id]
                else:
                    print(f"Error: Master folder {master_id} not found in XML either!")

            print(f"Loaded from cache: {len(self._cache_data.get('events', []))} events, {len(self.event_folders)} folders")
        except Exception as e:
            print(f"Cache load failed, falling back to XML: {e}")
            self._cache_loaded = False
            self.workspace = self._load_workspace()
            self.event_folders = self._load_event_folders()

    def has_cache(self) -> bool:
        """Check if cache file exists and was loaded successfully"""
        return self._cache_loaded

    @property
    def banks(self) -> Dict[str, Dict]:
        """Lazy load banks on first access"""
        if self._banks is None:
            self._banks = self._load_banks()
        return self._banks

    @property
    def buses(self) -> Dict[str, Dict]:
        """Lazy load buses on first access"""
        if self._buses is None:
            self._buses = self._load_buses()
        return self._buses

    @property
    def asset_folders(self) -> Dict[str, Dict]:
        """Lazy load asset folders on first access"""
        if self._asset_folders is None:
            self._asset_folders = self._load_asset_folders()
        return self._asset_folders

    def _load_workspace(self) -> Dict:
        """Load workspace.xml to get master folder references"""
        workspace_file = self.metadata_path / "Workspace.xml"
        if not workspace_file.exists():
            raise ValueError("Workspace.xml not found")

        tree = ET.parse(workspace_file)
        root = tree.getroot()

        workspace_obj = root.find(".//object[@class='Workspace']")
        if workspace_obj is None:
            raise ValueError("Workspace object not found")

        return {
            'id': workspace_obj.get('id'),
            'masterEventFolder': workspace_obj.find(".//relationship[@name='masterEventFolder']/destination").text,
            'masterBankFolder': workspace_obj.find(".//relationship[@name='masterBankFolder']/destination").text,
            'masterAssetFolder': workspace_obj.find(".//relationship[@name='masterAssetFolder']/destination").text
        }

    def _load_event_folders(self) -> Dict[str, Dict]:
        """Load all event folders from the EventFolder directory"""
        folders = {}
        event_folder_dir = self.metadata_path / "EventFolder"

        if not event_folder_dir.exists():
            return folders

        for xml_file in event_folder_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for obj in root.findall(".//object"):
                folder_id = obj.get('id')
                name_elem = obj.find(".//property[@name='name']/value")
                name = name_elem.text if name_elem is not None else "Unnamed"

                # Get parent folder
                parent_rel = obj.find(".//relationship[@name='folder']/destination")
                parent_id = parent_rel.text if parent_rel is not None else None

                folders[folder_id] = {
                    'name': name,
                    'parent': parent_id,
                    'path': xml_file,
                    'items': []
                }

        return folders

    def get_events_in_folder(self, folder_id: str) -> List[Dict]:
        """Get all events in a specific folder (recursively) - uses cache if available"""

        # Get all folder IDs in the hierarchy (this folder + all subfolders)
        target_folder_ids = {folder_id}

        def collect_subfolder_ids(current_folder_id: str):
            for fid, fdata in self.event_folders.items():
                if fdata.get('parent') == current_folder_id:
                    target_folder_ids.add(fid)
                    collect_subfolder_ids(fid)

        collect_subfolder_ids(folder_id)

        # FAST PATH: Use cache if available
        if self._cache_loaded and self._cache_data:
            events = []
            for event in self._cache_data.get('events', []):
                if event.get('folder_id') in target_folder_ids:
                    events.append({
                        'id': event['id'],
                        'name': event['name'],
                        'path': event.get('path', ''),
                        'folder_id': event['folder_id']
                    })
            return events

        # SLOW PATH: Parse XML files
        event_dir = self.metadata_path / "Event"
        if not event_dir.exists():
            return []

        events = []

        for xml_file in event_dir.glob("*.xml"):
            try:
                tree = ET.parse(xml_file)
                root = tree.getroot()

                for obj in root.findall(".//object[@class='Event']"):
                    folder_rel = obj.find(".//relationship[@name='folder']/destination")
                    event_folder_id = folder_rel.text if folder_rel is not None else None

                    if event_folder_id in target_folder_ids:
                        event_id = obj.get('id')
                        name_elem = obj.find(".//property[@name='name']/value")
                        event_name = name_elem.text if name_elem is not None else "Unnamed"

                        events.append({
                            'id': event_id,
                            'name': event_name,
                            'path': xml_file,
                            'folder_id': event_folder_id
                        })
            except Exception as e:
                continue

        return events

    def _load_banks(self) -> Dict[str, Dict]:
        """Load all banks from the Bank directory"""
        banks = {}
        bank_dir = self.metadata_path / "Bank"

        if not bank_dir.exists():
            return banks

        for xml_file in bank_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            # Look for both MasterBank and Bank classes
            for obj in root.findall(".//object"):
                obj_class = obj.get('class')
                if obj_class in ['MasterBank', 'Bank']:
                    bank_id = obj.get('id')
                    name_elem = obj.find(".//property[@name='name']/value")
                    name = name_elem.text if name_elem is not None else "Unnamed"

                    # Get parent relationship if exists
                    parent_rel = obj.find(".//relationship[@name='folder']/destination")
                    parent_id = parent_rel.text if parent_rel is not None else None

                    banks[bank_id] = {
                        'name': name,
                        'path': xml_file,
                        'parent': parent_id
                    }

        return banks

    def _load_buses(self) -> Dict[str, Dict]:
        """Load all mixer buses from Master.xml and Group directory"""
        buses = {}

        # Load master bus from Master.xml
        master_file = self.metadata_path / "Master.xml"
        if master_file.exists():
            tree = ET.parse(master_file)
            root = tree.getroot()

            for obj in root.findall(".//object"):
                obj_class = obj.get('class')
                if obj_class == 'MixerMaster':
                    bus_id = obj.get('id')
                    name_elem = obj.find(".//property[@name='name']/value")
                    name = name_elem.text if name_elem is not None else "Master Bus"

                    buses[bus_id] = {
                        'name': name,
                        'path': master_file,
                        'parent': None  # Master has no parent
                    }

        # Load other buses from Group directory
        group_dir = self.metadata_path / "Group"
        if group_dir.exists():
            for xml_file in group_dir.glob("*.xml"):
                tree = ET.parse(xml_file)
                root = tree.getroot()

                for obj in root.findall(".//object"):
                    obj_class = obj.get('class')
                    if obj_class == 'MixerGroup':
                        bus_id = obj.get('id')
                        name_elem = obj.find(".//property[@name='name']/value")
                        name = name_elem.text if name_elem is not None else "Unnamed"

                        # Get parent relationship (output)
                        parent_rel = obj.find(".//relationship[@name='output']/destination")
                        parent_id = parent_rel.text if parent_rel is not None else None

                        buses[bus_id] = {
                            'name': name,
                            'path': xml_file,
                            'parent': parent_id
                        }

        return buses

    def _get_master_bus_id(self) -> Optional[str]:
        """Get the master bus ID"""
        for bus_id, bus_info in self.buses.items():
            if bus_info['parent'] is None:  # Master bus has no parent
                return bus_id
        return None

    def _load_asset_folders(self) -> Dict[str, Dict]:
        """Load all asset folders from the Asset directory"""
        asset_folders = {}
        asset_dir = self.metadata_path / "Asset"

        if not asset_dir.exists():
            return asset_folders

        for xml_file in asset_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for obj in root.findall(".//object[@class='EncodableAsset']"):
                asset_id = obj.get('id')
                path_elem = obj.find(".//property[@name='assetPath']/value")
                asset_path = path_elem.text if path_elem is not None else ""

                master_folder_rel = obj.find(".//relationship[@name='masterAssetFolder']/destination")
                master_folder_id = master_folder_rel.text if master_folder_rel is not None else None

                asset_folders[asset_id] = {
                    'path': asset_path,
                    'xml_path': xml_file,
                    'master_folder': master_folder_id
                }

        return asset_folders

    def get_folder_hierarchy(self) -> List[Tuple[str, str, int]]:
        """Get event folders as a hierarchical list (name, id, depth)"""
        def build_hierarchy(folder_id: str, depth: int = 0) -> List[Tuple[str, str, int]]:
            result = []
            if folder_id in self.event_folders:
                folder = self.event_folders[folder_id]
                result.append((folder['name'], folder_id, depth))

                # Find children
                for fid, fdata in self.event_folders.items():
                    if fdata['parent'] == folder_id:
                        result.extend(build_hierarchy(fid, depth + 1))

            return result

        master_id = self.workspace['masterEventFolder']
        return build_hierarchy(master_id)

    def create_event_folder(self, name: str, parent_id: str, commit: bool = True) -> str:
        """
        Create a new event folder

        Args:
            name: Folder name
            parent_id: Parent folder ID
            commit: If True, write to XML immediately. If False, stage in memory only.

        Returns:
            New folder ID
        """
        folder_id = "{" + str(uuid.uuid4()) + "}"

        # Build folder data
        folder_data = {
            'name': name,
            'parent': parent_id,
            'path': None,  # Will be set when committed
            'items': []
        }

        if commit:
            # Create XML
            root = ET.Element('objects', serializationModel="Studio.02.02.00")
            obj = ET.SubElement(root, 'object', {'class': 'EventFolder', 'id': folder_id})

            # Add name property
            prop = ET.SubElement(obj, 'property', name='name')
            value = ET.SubElement(prop, 'value')
            value.text = name

            # Add parent relationship
            rel = ET.SubElement(obj, 'relationship', name='folder')
            dest = ET.SubElement(rel, 'destination')
            dest.text = parent_id

            # Write to file
            folder_file = self.metadata_path / "EventFolder" / f"{folder_id}.xml"
            self._write_pretty_xml(root, folder_file)

            # Update path
            folder_data['path'] = folder_file

            # Add to committed folders
            self.event_folders[folder_id] = folder_data
        else:
            # Stage in memory only
            self._pending_event_folders[folder_id] = folder_data

        return folder_id

    def create_bank(self, name: str, parent_id: str = None) -> str:
        """Create a new bank folder (BankFolder object)"""
        bank_id = "{" + str(uuid.uuid4()) + "}"

        # Create XML
        root = ET.Element('objects', serializationModel="Studio.02.02.00")
        obj = ET.SubElement(root, 'object', {'class': 'BankFolder', 'id': bank_id})

        # Add name property
        prop = ET.SubElement(obj, 'property', name='name')
        value = ET.SubElement(prop, 'value')
        value.text = name

        # Add parent relationship if exists
        if parent_id:
            rel = ET.SubElement(obj, 'relationship', name='folder')
            dest = ET.SubElement(rel, 'destination')
            dest.text = parent_id

        # Ensure BankFolder directory exists
        bank_folder_dir = self.metadata_path / "BankFolder"
        bank_folder_dir.mkdir(exist_ok=True)

        # Write to file in BankFolder directory
        bank_file = bank_folder_dir / f"{bank_id}.xml"
        self._write_pretty_xml(root, bank_file)

        # Update internal structure
        self.banks[bank_id] = {
            'name': name,
            'path': bank_file,
            'parent': parent_id
        }

        return bank_id

    def delete_bank(self, bank_id: str):
        """Delete a bank"""
        if bank_id in self.banks:
            bank_path = self.banks[bank_id]['path']
            if bank_path.exists():
                bank_path.unlink()
            del self.banks[bank_id]

    def create_asset_folder(self, name: str, parent_path: str, commit: bool = True) -> str:
        """
        Create a new asset folder

        Args:
            name: Folder name (no slashes)
            parent_path: Parent folder path (e.g., "Characters/")
            commit: If True, write to XML immediately. If False, stage in memory only.

        Returns:
            New asset folder ID
        """
        # Remove any slashes from the name
        name = name.replace('/', '').replace('\\', '')
        if not name:
            raise ValueError("Invalid folder name: cannot be empty after removing slashes")

        # Build new path
        new_path = parent_path + name + '/'

        # Check for conflicts in both committed and pending folders
        all_asset_folders = {**self.asset_folders, **self._pending_asset_folders}
        for asset_id, asset_data in all_asset_folders.items():
            if asset_data.get('path') == new_path:
                raise ValueError(f"Asset folder with path '{new_path}' already exists")

        asset_id = "{" + str(uuid.uuid4()) + "}"
        master_id = self.workspace['masterAssetFolder']

        # Build folder data
        folder_data = {
            'path': new_path,
            'xml_path': None,  # Will be set when committed
            'master_folder': master_id
        }

        if commit:
            # Create XML structure
            root_elem = ET.Element('objects', serializationModel="Studio.02.02.00")
            obj = ET.SubElement(root_elem, 'object', {'class': 'EncodableAsset', 'id': asset_id})

            # Add assetPath property
            prop = ET.SubElement(obj, 'property', name='assetPath')
            value = ET.SubElement(prop, 'value')
            value.text = new_path

            # Add masterAssetFolder relationship
            rel = ET.SubElement(obj, 'relationship', name='masterAssetFolder')
            dest = ET.SubElement(rel, 'destination')
            dest.text = master_id

            # Write to file
            asset_file = self.metadata_path / "Asset" / f"{asset_id}.xml"
            self._write_pretty_xml(root_elem, asset_file)

            # Update path
            folder_data['xml_path'] = asset_file

            # Add to committed folders
            self.asset_folders[asset_id] = folder_data
        else:
            # Stage in memory only
            self._pending_asset_folders[asset_id] = folder_data

        return asset_id

    def create_bus(self, name: str, parent_id: str = None) -> str:
        """Create a new bus (MixerGroup)"""
        bus_id = "{" + str(uuid.uuid4()) + "}"

        # Create XML structure for MixerGroup
        root = ET.Element('objects', serializationModel="Studio.02.02.00")
        obj = ET.SubElement(root, 'object', {'class': 'MixerGroup', 'id': bus_id})

        # Add name property
        prop = ET.SubElement(obj, 'property', name='name')
        value = ET.SubElement(prop, 'value')
        value.text = name

        # Add effectChain
        effect_chain_id = "{" + str(uuid.uuid4()) + "}"
        rel_effect = ET.SubElement(obj, 'relationship', name='effectChain')
        dest_effect = ET.SubElement(rel_effect, 'destination')
        dest_effect.text = effect_chain_id

        # Add panner
        panner_id = "{" + str(uuid.uuid4()) + "}"
        rel_panner = ET.SubElement(obj, 'relationship', name='panner')
        dest_panner = ET.SubElement(rel_panner, 'destination')
        dest_panner.text = panner_id

        # Add output (parent relationship)
        # If no parent specified, route to Master Bus
        if not parent_id:
            # Get master bus from Mixer.xml
            parent_id = self._get_master_bus_id()

        if parent_id:
            rel_output = ET.SubElement(obj, 'relationship', name='output')
            dest_output = ET.SubElement(rel_output, 'destination')
            dest_output.text = parent_id

        # Add effect chain object
        effect_chain_obj = ET.SubElement(root, 'object', {'class': 'MixerBusEffectChain', 'id': effect_chain_id})
        fader_id = "{" + str(uuid.uuid4()) + "}"
        rel_effects = ET.SubElement(effect_chain_obj, 'relationship', name='effects')
        dest_fader = ET.SubElement(rel_effects, 'destination')
        dest_fader.text = fader_id

        # Add panner object
        ET.SubElement(root, 'object', {'class': 'MixerBusPanner', 'id': panner_id})

        # Add fader object
        ET.SubElement(root, 'object', {'class': 'MixerBusFader', 'id': fader_id})

        # Ensure Group folder exists
        group_folder = self.metadata_path / "Group"
        group_folder.mkdir(exist_ok=True)

        # Write to file
        bus_file = group_folder / f"{bus_id}.xml"
        self._write_pretty_xml(root, bus_file)

        # Update internal structure
        self.buses[bus_id] = {
            'name': name,
            'path': bus_file,
            'parent': parent_id
        }

        return bus_id

    def delete_bus(self, bus_id: str):
        """Delete a bus"""
        if bus_id in self.buses:
            bus_path = self.buses[bus_id]['path']
            if bus_path.exists():
                bus_path.unlink()
            del self.buses[bus_id]

    def delete_folder(self, folder_id: str):
        """Delete an event folder"""
        if folder_id in self.event_folders:
            folder_path = self.event_folders[folder_id]['path']
            if folder_path.exists():
                folder_path.unlink()
            del self.event_folders[folder_id]

    def commit_pending_folders(self) -> Tuple[int, int]:
        """
        Commit all pending folders to XML files.
        This should be called before starting an import operation.

        Returns:
            Tuple of (num_event_folders_committed, num_asset_folders_committed)
        """
        event_count = 0
        asset_count = 0
        committed_event_ids = []
        committed_asset_ids = []

        try:
            # Phase 1: Commit event folders avec tri topologique
            pending_event_items = list(self._pending_event_folders.items())

            while pending_event_items:
                made_progress = False
                remaining = []

                for folder_id, folder_data in pending_event_items:
                    parent_id = folder_data['parent']

                    # Vérifier si le parent est committé
                    parent_committed = (parent_id in self.event_folders or
                                       parent_id in committed_event_ids or
                                       parent_id == self.workspace.get('masterEventFolder'))

                    if parent_committed:
                        # Créer XML
                        root = ET.Element('objects', serializationModel="Studio.02.02.00")
                        obj = ET.SubElement(root, 'object', {'class': 'EventFolder', 'id': folder_id})

                        # Add name property
                        prop = ET.SubElement(obj, 'property', name='name')
                        value = ET.SubElement(prop, 'value')
                        value.text = folder_data['name']

                        # Add parent relationship
                        rel = ET.SubElement(obj, 'relationship', name='folder')
                        dest = ET.SubElement(rel, 'destination')
                        dest.text = parent_id

                        # Write to file
                        folder_file = self.metadata_path / "EventFolder" / f"{folder_id}.xml"
                        self._write_pretty_xml(root, folder_file)

                        # Update data and move to committed
                        folder_data['path'] = folder_file
                        self.event_folders[folder_id] = folder_data
                        committed_event_ids.append(folder_id)
                        event_count += 1
                        made_progress = True
                    else:
                        remaining.append((folder_id, folder_data))

                # Deadlock detection
                if not made_progress and remaining:
                    orphaned = [f"{fdata['name']} (parent: {fdata['parent']})"
                               for fid, fdata in remaining]
                    raise ValueError(f"Cannot commit folders with missing parents: {orphaned}")

                pending_event_items = remaining

            # Phase 2: Commit asset folders
            for asset_id, folder_data in self._pending_asset_folders.items():
                # Create XML structure
                root_elem = ET.Element('objects', serializationModel="Studio.02.02.00")
                obj = ET.SubElement(root_elem, 'object', {'class': 'EncodableAsset', 'id': asset_id})

                # Add assetPath property
                prop = ET.SubElement(obj, 'property', name='assetPath')
                value = ET.SubElement(prop, 'value')
                value.text = folder_data['path']

                # Add masterAssetFolder relationship
                rel = ET.SubElement(obj, 'relationship', name='masterAssetFolder')
                dest = ET.SubElement(rel, 'destination')
                dest.text = folder_data['master_folder']

                # Write to file
                asset_file = self.metadata_path / "Asset" / f"{asset_id}.xml"
                self._write_pretty_xml(root_elem, asset_file)

                # Update data and move to committed
                folder_data['xml_path'] = asset_file
                self.asset_folders[asset_id] = folder_data
                committed_asset_ids.append(asset_id)
                asset_count += 1

            # Clear pending folders
            self._pending_event_folders.clear()
            self._pending_asset_folders.clear()

            return (event_count, asset_count)

        except Exception as e:
            # Rollback : supprimer les fichiers créés
            for folder_id in committed_event_ids:
                if folder_id in self.event_folders:
                    folder_path = self.event_folders[folder_id].get('path')
                    if folder_path and folder_path.exists():
                        folder_path.unlink()
                    del self.event_folders[folder_id]

            for asset_id in committed_asset_ids:
                if asset_id in self.asset_folders:
                    asset_path = self.asset_folders[asset_id].get('xml_path')
                    if asset_path and asset_path.exists():
                        asset_path.unlink()
                    del self.asset_folders[asset_id]

            raise RuntimeError(f"Failed to commit pending folders: {e}")

    def clear_pending_folders(self) -> int:
        """
        Clear all pending folders without committing them.
        This should be called when the user closes the application without importing.

        Returns:
            Number of pending folders cleared
        """
        count = len(self._pending_event_folders) + len(self._pending_asset_folders)
        self._pending_event_folders.clear()
        self._pending_asset_folders.clear()
        return count

    def get_all_event_folders(self) -> Dict[str, Dict]:
        """
        Get all event folders (both committed and pending).
        Useful for tree displays.
        """
        return {**self.event_folders, **self._pending_event_folders}

    def get_all_asset_folders(self) -> Dict[str, Dict]:
        """
        Get all asset folders (both committed and pending).
        Useful for tree displays.
        """
        return {**self.asset_folders, **self._pending_asset_folders}

    def is_folder_pending(self, folder_id: str) -> bool:
        """Check if a folder is pending (not yet committed to XML)"""
        return (folder_id in self._pending_event_folders or
                folder_id in self._pending_asset_folders)

    def _write_pretty_xml(self, element: ET.Element, filepath: Path):
        """Write XML with proper formatting"""
        xml_str = ET.tostring(element, encoding='unicode')
        dom = minidom.parseString(xml_str)
        pretty_xml = dom.toprettyxml(indent='\t', encoding='UTF-8')

        with open(filepath, 'wb') as f:
            f.write(pretty_xml)

    def copy_event_from_template(self, template_event_id: str, new_name: str,
                                  dest_folder_id: str, bank_id: str, bus_id: str,
                                  audio_files: List[str], audio_asset_folder: str) -> str:
        """
        Copy an event from template and assign audio files to it

        Args:
            template_event_id: ID of the template event to copy
            new_name: New name for the event
            dest_folder_id: Destination folder ID
            bank_id: Bank ID to assign
            bus_id: Bus ID to assign
            audio_files: List of audio file paths to assign
            audio_asset_folder: Folder where audio assets should be placed

        Returns:
            New event ID
        """
        import shutil

        # Find template event
        template_event_path = self.metadata_path / "Event" / f"{template_event_id}.xml"
        if not template_event_path.exists():
            raise ValueError(f"Template event {template_event_id} not found")

        # Parse template XML
        template_tree = ET.parse(template_event_path)
        template_root = template_tree.getroot()

        # Create new event ID
        new_event_id = "{" + str(uuid.uuid4()) + "}"

        # Deep copy the entire XML structure
        new_root = ET.Element('objects', serializationModel="Studio.02.02.00")

        # Map old IDs to new IDs
        id_map = {}

        # First pass: collect all IDs and create new ones
        for obj in template_root.findall(".//object"):
            old_id = obj.get('id')
            new_id = "{" + str(uuid.uuid4()) + "}"
            id_map[old_id] = new_id

        # Override the event ID with our chosen ID
        event_obj = template_root.find(".//object[@class='Event']")
        if event_obj is not None:
            id_map[event_obj.get('id')] = new_event_id

        # Second pass: copy objects and update references
        for obj in template_root.findall(".//object"):
            old_id = obj.get('id')
            new_obj = ET.SubElement(new_root, 'object')
            new_obj.set('class', obj.get('class'))
            new_obj.set('id', id_map[old_id])

            # Copy properties
            for prop in obj.findall('property'):
                new_prop = ET.SubElement(new_obj, 'property')
                new_prop.set('name', prop.get('name'))
                value_elem = prop.find('value')
                if value_elem is not None:
                    new_value = ET.SubElement(new_prop, 'value')
                    # Special case: replace event name
                    if obj.get('class') == 'Event' and prop.get('name') == 'name':
                        new_value.text = new_name
                    else:
                        new_value.text = value_elem.text

            # Copy relationships and update destinations
            for rel in obj.findall('relationship'):
                new_rel = ET.SubElement(new_obj, 'relationship')
                new_rel.set('name', rel.get('name'))

                # Special cases for relationships we want to override
                if obj.get('class') == 'Event':
                    if rel.get('name') == 'folder':
                        # Change to destination folder
                        dest = ET.SubElement(new_rel, 'destination')
                        dest.text = dest_folder_id
                        continue
                    elif rel.get('name') == 'banks':
                        # Change to selected bank
                        dest = ET.SubElement(new_rel, 'destination')
                        dest.text = bank_id
                        continue

                if obj.get('class') == 'MixerInput' and rel.get('name') == 'output':
                    # Change to selected bus
                    dest = ET.SubElement(new_rel, 'destination')
                    dest.text = bus_id
                    continue

                # Copy all destinations
                for dest_elem in rel.findall('destination'):
                    new_dest = ET.SubElement(new_rel, 'destination')
                    old_dest_id = dest_elem.text
                    # Update to new ID if it's in our map
                    new_dest.text = id_map.get(old_dest_id, old_dest_id)

        # Create audio files and add them to the event
        if audio_files:
            # Create AudioFile objects and SingleSound objects
            single_sound_ids = []

            for audio_file_path in audio_files:
                # Get the source audio file
                audio_file_src = Path(audio_file_path)

                # Create the FMOD asset path (relative to Assets folder)
                # Combine the asset folder path with the filename
                asset_relative_path = audio_asset_folder + audio_file_src.name

                # Copy audio file to FMOD project Assets folder
                assets_folder = self.project_path.parent / "Assets"
                dest_folder = assets_folder / Path(audio_asset_folder)
                dest_folder.mkdir(parents=True, exist_ok=True)

                dest_file = dest_folder / audio_file_src.name
                shutil.copy2(audio_file_src, dest_file)

                # Create AudioFile using the helper method
                # Pass the actual file path for reading properties, and the FMOD asset path
                audio_file_id = self.create_audio_file(str(audio_file_src), asset_relative_path)

                # Create SingleSound object
                single_sound_id = "{" + str(uuid.uuid4()) + "}"
                single_sound_obj = ET.SubElement(new_root, 'object', {'class': 'SingleSound', 'id': single_sound_id})

                # Add audioFile relationship
                rel_audio = ET.SubElement(single_sound_obj, 'relationship', name='audioFile')
                dest_audio = ET.SubElement(rel_audio, 'destination')
                dest_audio.text = audio_file_id

                single_sound_ids.append(single_sound_id)

            # Create MultiSound object
            multi_sound_id = "{" + str(uuid.uuid4()) + "}"
            multi_sound_obj = ET.SubElement(new_root, 'object', {'class': 'MultiSound', 'id': multi_sound_id})

            # Add length property (calculate from first audio file)
            try:
                with wave.open(audio_files[0], 'rb') as wav_file:
                    length_seconds = wav_file.getnframes() / float(wav_file.getframerate())
                    prop_ms_length = ET.SubElement(multi_sound_obj, 'property', name='length')
                    value_ms_length = ET.SubElement(prop_ms_length, 'value')
                    value_ms_length.text = str(length_seconds)
            except:
                # If we can't read the file, use a default length
                prop_ms_length = ET.SubElement(multi_sound_obj, 'property', name='length')
                value_ms_length = ET.SubElement(prop_ms_length, 'value')
                value_ms_length.text = "0.0"

            # Add sounds relationship
            rel_sounds = ET.SubElement(multi_sound_obj, 'relationship', name='sounds')
            for ss_id in single_sound_ids:
                dest_sound = ET.SubElement(rel_sounds, 'destination')
                dest_sound.text = ss_id

            # Find or create GroupTrack
            group_track = new_root.find(".//object[@class='GroupTrack']")
            if group_track is None:
                # Create a new GroupTrack if it doesn't exist
                group_track_id = "{" + str(uuid.uuid4()) + "}"
                group_track = ET.SubElement(new_root, 'object', {'class': 'GroupTrack', 'id': group_track_id})

                # Create EventMixerGroup for the track
                mixer_group_id = "{" + str(uuid.uuid4()) + "}"
                mixer_group = ET.SubElement(new_root, 'object', {'class': 'EventMixerGroup', 'id': mixer_group_id})

                # Add name property to mixer group
                prop_mg_name = ET.SubElement(mixer_group, 'property', name='name')
                value_mg_name = ET.SubElement(prop_mg_name, 'value')
                value_mg_name.text = "Audio 1"

                # Add effectChain to mixer group
                effect_chain_id = "{" + str(uuid.uuid4()) + "}"
                rel_effect_chain = ET.SubElement(mixer_group, 'relationship', name='effectChain')
                dest_effect_chain = ET.SubElement(rel_effect_chain, 'destination')
                dest_effect_chain.text = effect_chain_id

                # Add panner to mixer group
                panner_id = "{" + str(uuid.uuid4()) + "}"
                rel_panner = ET.SubElement(mixer_group, 'relationship', name='panner')
                dest_panner = ET.SubElement(rel_panner, 'destination')
                dest_panner.text = panner_id

                # Add output to EventMixerMaster
                event_mixer_master = new_root.find(".//object[@class='EventMixerMaster']")
                if event_mixer_master is not None:
                    rel_output = ET.SubElement(mixer_group, 'relationship', name='output')
                    dest_output = ET.SubElement(rel_output, 'destination')
                    dest_output.text = event_mixer_master.get('id')

                # Create effect chain
                effect_chain = ET.SubElement(new_root, 'object', {'class': 'MixerBusEffectChain', 'id': effect_chain_id})
                fader_id = "{" + str(uuid.uuid4()) + "}"
                rel_effects = ET.SubElement(effect_chain, 'relationship', name='effects')
                dest_fader = ET.SubElement(rel_effects, 'destination')
                dest_fader.text = fader_id

                # Create panner
                ET.SubElement(new_root, 'object', {'class': 'MixerBusPanner', 'id': panner_id})

                # Create fader
                ET.SubElement(new_root, 'object', {'class': 'MixerBusFader', 'id': fader_id})

                # Add mixerGroup relationship to GroupTrack
                rel_mixer = ET.SubElement(group_track, 'relationship', name='mixerGroup')
                dest_mixer = ET.SubElement(rel_mixer, 'destination')
                dest_mixer.text = mixer_group_id

                # Add GroupTrack to Event's groupTracks relationship
                event_obj = new_root.find(".//object[@class='Event']")
                if event_obj is not None:
                    rel_group_tracks = event_obj.find(".//relationship[@name='groupTracks']")
                    if rel_group_tracks is None:
                        rel_group_tracks = ET.SubElement(event_obj, 'relationship', name='groupTracks')
                    dest_group_track = ET.SubElement(rel_group_tracks, 'destination')
                    dest_group_track.text = group_track_id

            # Update GroupTrack to reference MultiSound
            rel_modules = group_track.find(".//relationship[@name='modules']")
            if rel_modules is None:
                rel_modules = ET.SubElement(group_track, 'relationship', name='modules')
            else:
                # Clear existing modules
                for dest in list(rel_modules.findall('destination')):
                    rel_modules.remove(dest)

            dest_module = ET.SubElement(rel_modules, 'destination')
            dest_module.text = multi_sound_id

            # Update Timeline to reference MultiSound
            timeline = new_root.find(".//object[@class='Timeline']")
            if timeline is not None:
                rel_timeline_modules = timeline.find(".//relationship[@name='modules']")
                if rel_timeline_modules is None:
                    rel_timeline_modules = ET.SubElement(timeline, 'relationship', name='modules')
                else:
                    # Clear existing modules
                    for dest in list(rel_timeline_modules.findall('destination')):
                        rel_timeline_modules.remove(dest)

                dest_timeline_module = ET.SubElement(rel_timeline_modules, 'destination')
                dest_timeline_module.text = multi_sound_id

        # Write new event file
        event_file = self.metadata_path / "Event" / f"{new_event_id}.xml"
        self._write_pretty_xml(new_root, event_file)

        return new_event_id

    def create_audio_file(self, audio_file_path: str, asset_relative_path: str) -> str:
        """
        Create an AudioFile XML entry in the FMOD project

        Args:
            audio_file_path: Full path to the source audio file
            asset_relative_path: Relative path within FMOD project (e.g., "Characters/Cat Boss Rich/Cat_Boss_Rich_Run_03.wav")

        Returns:
            The new AudioFile UUID
        """
        # Generate new UUID for AudioFile
        audio_file_id = "{" + str(uuid.uuid4()) + "}"

        # Read audio file properties
        try:
            with wave.open(audio_file_path, 'rb') as wav_file:
                # Get audio properties
                channel_count = wav_file.getnchannels()
                sample_rate = wav_file.getframerate()
                n_frames = wav_file.getnframes()

                # Calculate frequency in kHz
                frequency_khz = sample_rate / 1000.0

                # Calculate length in seconds
                length_seconds = n_frames / float(sample_rate)
        except Exception as e:
            raise ValueError(f"Failed to read audio file properties: {e}")

        # Create XML structure
        root = ET.Element('objects', serializationModel="Studio.02.02.00")
        obj = ET.SubElement(root, 'object', {'class': 'AudioFile', 'id': audio_file_id})

        # Add assetPath property
        prop_path = ET.SubElement(obj, 'property', name='assetPath')
        value_path = ET.SubElement(prop_path, 'value')
        value_path.text = asset_relative_path

        # Add frequencyInKHz property
        prop_freq = ET.SubElement(obj, 'property', name='frequencyInKHz')
        value_freq = ET.SubElement(prop_freq, 'value')
        value_freq.text = str(frequency_khz)

        # Add channelCount property
        prop_channels = ET.SubElement(obj, 'property', name='channelCount')
        value_channels = ET.SubElement(prop_channels, 'value')
        value_channels.text = str(channel_count)

        # Add length property
        prop_length = ET.SubElement(obj, 'property', name='length')
        value_length = ET.SubElement(prop_length, 'value')
        value_length.text = str(length_seconds)

        # Add masterAssetFolder relationship
        rel = ET.SubElement(obj, 'relationship', name='masterAssetFolder')
        dest = ET.SubElement(rel, 'destination')
        dest.text = self.workspace['masterAssetFolder']

        # Ensure AudioFile directory exists
        audio_file_dir = self.metadata_path / "AudioFile"
        audio_file_dir.mkdir(exist_ok=True)

        # Write XML to file
        audio_file_xml_path = audio_file_dir / f"{audio_file_id}.xml"
        self._write_pretty_xml(root, audio_file_xml_path)

        return audio_file_id
