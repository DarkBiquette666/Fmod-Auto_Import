"""
FMOD Project Management Module
Handles FMOD Studio project XML manipulation and metadata management.
"""

import os
import json
import uuid
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from xml.dom import minidom
import wave

from .core.xml_loader import XMLLoader
from .core.xml_writer import write_pretty_xml
from .core.pending_folder_manager import PendingFolderManager
from .core.bus_manager import BusManager
from .core.bank_manager import BankManager
from .core.event_folder_manager import EventFolderManager
from .core.asset_folder_manager import AssetFolderManager
from .core.event_creator import EventCreator
from .core.audio_file_manager import AudioFileManager


class FMODProject:
    """Represents a FMOD Studio project and handles XML manipulation"""

    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
        self.metadata_path = self.project_path.parent / "Metadata"

        if not self.metadata_path.exists():
            raise ValueError(f"Metadata folder not found: {self.metadata_path}")

        # Initialize managers
        self._xml_loader = XMLLoader(self.metadata_path)
        self._pending_manager = PendingFolderManager()

        # Load only minimal data needed for UI at startup
        self.workspace = self._xml_loader.load_workspace()
        self.event_folders = self._xml_loader.load_event_folders()

        # OPTIMIZATION: Lazy load everything else
        self._banks = None
        self._buses = None
        self._asset_folders = None
        self._events_by_folder = None

    # CACHE LIKELY OBSOLETE - Remove if no performance issues
    # Code kept temporarily in case we notice slowdowns
    # def _load_from_cache(self):
    #     """Load project data from JSON cache (generated by FMOD Studio script)"""
    #     try:
    #         with open(self.cache_path, 'r', encoding='utf-8') as f:
    #             self._cache_data = json.load(f)
    #         self._cache_loaded = True
    #
    #         # Load workspace first
    #         self.workspace = self._load_workspace()
    #
    #         # Build event_folders from cache
    #         self.event_folders = {}
    #         for folder in self._cache_data.get('folders', []):
    #             self.event_folders[folder['id']] = {
    #                 'name': folder['name'],
    #                 'parent': folder['parent'],
    #                 'path': None,
    #                 'items': []
    #             }
    #
    #         # FALLBACK: If master folder is missing from cache, add it from workspace
    #         master_id = self.workspace.get('masterEventFolder')
    #         if master_id and master_id not in self.event_folders:
    #             # Load master folder from XML
    #             print(f"Warning: Master folder {master_id} not in cache, loading from XML...")
    #             xml_folders = self._load_event_folders()
    #             if master_id in xml_folders:
    #                 self.event_folders[master_id] = xml_folders[master_id]
    #             else:
    #                 print(f"Error: Master folder {master_id} not found in XML either!")
    #
    #         print(f"Loaded from cache: {len(self._cache_data.get('events', []))} events, {len(self.event_folders)} folders")
    #     except Exception as e:
    #         print(f"Cache load failed, falling back to XML: {e}")
    #         self._cache_loaded = False
    #         self.workspace = self._load_workspace()
    #         self.event_folders = self._load_event_folders()
    #
    # def has_cache(self) -> bool:
    #     """Check if cache file exists and was loaded successfully"""
    #     return self._cache_loaded

    @property
    def banks(self) -> Dict[str, Dict]:
        """Lazy load banks on first access"""
        if self._banks is None:
            self._banks = self._xml_loader.load_banks()
        return self._banks

    @property
    def buses(self) -> Dict[str, Dict]:
        """Lazy load buses on first access"""
        if self._buses is None:
            self._buses = self._xml_loader.load_buses()
        return self._buses

    @property
    def asset_folders(self) -> Dict[str, Dict]:
        """Lazy load asset folders on first access"""
        if self._asset_folders is None:
            self._asset_folders = self._xml_loader.load_asset_folders()
        return self._asset_folders

    def _load_workspace(self) -> Dict:
        """Load workspace.xml to get master folder references"""
        workspace_file = self.metadata_path / "Workspace.xml"
        if not workspace_file.exists():
            raise ValueError("Workspace.xml not found")

        tree = ET.parse(workspace_file)
        root = tree.getroot()

        workspace_obj = root.find(".//object[@class='Workspace']")
        if workspace_obj is None:
            raise ValueError("Workspace object not found")

        return {
            'id': workspace_obj.get('id'),
            'masterEventFolder': workspace_obj.find(".//relationship[@name='masterEventFolder']/destination").text,
            'masterBankFolder': workspace_obj.find(".//relationship[@name='masterBankFolder']/destination").text,
            'masterAssetFolder': workspace_obj.find(".//relationship[@name='masterAssetFolder']/destination").text
        }

    def _load_event_folders(self) -> Dict[str, Dict]:
        """Load all event folders from the EventFolder directory"""
        folders = {}
        event_folder_dir = self.metadata_path / "EventFolder"

        if not event_folder_dir.exists():
            return folders

        for xml_file in event_folder_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for obj in root.findall(".//object"):
                folder_id = obj.get('id')
                name_elem = obj.find(".//property[@name='name']/value")
                name = name_elem.text if name_elem is not None else "Unnamed"

                # Get parent folder
                parent_rel = obj.find(".//relationship[@name='folder']/destination")
                parent_id = parent_rel.text if parent_rel is not None else None

                folders[folder_id] = {
                    'name': name,
                    'parent': parent_id,
                    'path': xml_file,
                    'items': []
                }

        return folders

    def get_events_in_folder(self, folder_id: str) -> List[Dict]:
        """Get all events in a specific folder (delegates to EventFolderManager)"""
        return EventFolderManager.get_events_in_folder(
            folder_id, self.event_folders, self.metadata_path
        )

    def get_bus_from_template_events(self, folder_id: str) -> Tuple[Optional[str], bool, set]:
        """Analyze bus routing in template folder events (delegates to EventFolderManager)"""
        return EventFolderManager.get_bus_from_template_events(
            folder_id, self.event_folders, self.metadata_path
        )

    def _load_banks(self) -> Dict[str, Dict]:
        """Load all banks from the Bank directory"""
        banks = {}
        bank_dir = self.metadata_path / "Bank"

        if not bank_dir.exists():
            return banks

        for xml_file in bank_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            # Look for both MasterBank and Bank classes
            for obj in root.findall(".//object"):
                obj_class = obj.get('class')
                if obj_class in ['MasterBank', 'Bank']:
                    bank_id = obj.get('id')
                    name_elem = obj.find(".//property[@name='name']/value")
                    name = name_elem.text if name_elem is not None else "Unnamed"

                    # Get parent relationship if exists
                    parent_rel = obj.find(".//relationship[@name='folder']/destination")
                    parent_id = parent_rel.text if parent_rel is not None else None

                    banks[bank_id] = {
                        'name': name,
                        'path': xml_file,
                        'parent': parent_id
                    }

        return banks

    def _load_buses(self) -> Dict[str, Dict]:
        """Load all mixer buses from Master.xml and Group directory"""
        buses = {}

        # Load master bus from Master.xml
        master_file = self.metadata_path / "Master.xml"
        if master_file.exists():
            tree = ET.parse(master_file)
            root = tree.getroot()

            for obj in root.findall(".//object"):
                obj_class = obj.get('class')
                if obj_class == 'MixerMaster':
                    bus_id = obj.get('id')
                    name_elem = obj.find(".//property[@name='name']/value")
                    name = name_elem.text if name_elem is not None else "Master Bus"

                    buses[bus_id] = {
                        'name': name,
                        'path': master_file,
                        'parent': None  # Master has no parent
                    }

        # Load other buses from Group directory
        group_dir = self.metadata_path / "Group"
        if group_dir.exists():
            for xml_file in group_dir.glob("*.xml"):
                tree = ET.parse(xml_file)
                root = tree.getroot()

                for obj in root.findall(".//object"):
                    obj_class = obj.get('class')
                    if obj_class == 'MixerGroup':
                        bus_id = obj.get('id')
                        name_elem = obj.find(".//property[@name='name']/value")
                        name = name_elem.text if name_elem is not None else "Unnamed"

                        # Get parent relationship (output)
                        parent_rel = obj.find(".//relationship[@name='output']/destination")
                        parent_id = parent_rel.text if parent_rel is not None else None

                        buses[bus_id] = {
                            'name': name,
                            'path': xml_file,
                            'parent': parent_id
                        }

        return buses

    def _get_master_bus_id(self) -> Optional[str]:
        """Get the master bus ID (delegates to BusManager)"""
        return BusManager.get_master_bus_id(self.buses)

    def _load_asset_folders(self) -> Dict[str, Dict]:
        """Load all asset folders from the Asset directory"""
        asset_folders = {}
        asset_dir = self.metadata_path / "Asset"

        if not asset_dir.exists():
            return asset_folders

        for xml_file in asset_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for obj in root.findall(".//object[@class='EncodableAsset']"):
                asset_id = obj.get('id')
                path_elem = obj.find(".//property[@name='assetPath']/value")
                asset_path = path_elem.text if path_elem is not None else ""

                master_folder_rel = obj.find(".//relationship[@name='masterAssetFolder']/destination")
                master_folder_id = master_folder_rel.text if master_folder_rel is not None else None

                asset_folders[asset_id] = {
                    'path': asset_path,
                    'xml_path': xml_file,
                    'master_folder': master_folder_id
                }

        return asset_folders

    def get_folder_hierarchy(self) -> List[Tuple[str, str, int]]:
        """Get event folders as a hierarchical list (delegates to EventFolderManager)"""
        master_id = self.workspace['masterEventFolder']
        return EventFolderManager.get_hierarchy(master_id, self.event_folders)

    def create_event_folder(self, name: str, parent_id: str, commit: bool = True) -> str:
        """Create a new event folder (delegates to EventFolderManager)"""
        return EventFolderManager.create(
            name, parent_id, commit, self.metadata_path,
            self.event_folders, self._pending_manager
        )

    def create_bank(self, name: str, parent_id: str = None) -> str:
        """Create a new bank folder (delegates to BankManager)"""
        return BankManager.create(name, parent_id, self.metadata_path, self.banks)

    def delete_bank(self, bank_id: str):
        """Delete a bank (delegates to BankManager)"""
        BankManager.delete(bank_id, self.banks, self.metadata_path)

    def create_asset_folder(self, name: str, parent_path: str, commit: bool = True) -> str:
        """Create a new asset folder (delegates to AssetFolderManager)"""
        return AssetFolderManager.create(
            name, parent_path, commit, self.metadata_path,
            self.asset_folders, self._pending_manager, self.workspace
        )

    def create_bus(self, name: str, parent_id: str = None) -> str:
        """Create a new bus (delegates to BusManager)"""
        # If no parent specified, route to Master Bus
        if not parent_id:
            parent_id = self._get_master_bus_id()
        return BusManager.create(name, parent_id, self.metadata_path, self.buses)

    def delete_bus(self, bus_id: str):
        """Delete a bus (delegates to BusManager)"""
        BusManager.delete(bus_id, self.buses, self.metadata_path)

    def delete_folder(self, folder_id: str):
        """Delete an event folder (delegates to EventFolderManager)"""
        EventFolderManager.delete(folder_id, self.event_folders, self.metadata_path)

    def commit_pending_folders(self) -> Tuple[int, int]:
        """
        Commit all pending folders to XML files (delegates to PendingFolderManager).

        Returns:
            Tuple of (num_event_folders_committed, num_asset_folders_committed)
        """
        return self._pending_manager.commit_all(
            self.event_folders,
            self.asset_folders,
            self.workspace,
            self.metadata_path
        )

    def clear_pending_folders(self) -> int:
        """
        Clear all pending folders without committing them (delegates to PendingFolderManager).

        Returns:
            Number of pending folders cleared
        """
        return self._pending_manager.clear_all()

    def get_all_event_folders(self) -> Dict[str, Dict]:
        """
        Get all event folders (both committed and pending).
        Useful for tree displays.
        """
        return self._pending_manager.get_all_event_folders(self.event_folders)

    def get_all_asset_folders(self) -> Dict[str, Dict]:
        """
        Get all asset folders (both committed and pending).
        Useful for tree displays.
        """
        return self._pending_manager.get_all_asset_folders(self.asset_folders)

    def is_folder_pending(self, folder_id: str) -> bool:
        """Check if a folder is pending (not yet committed to XML)"""
        return self._pending_manager.is_pending(folder_id)

    def _write_pretty_xml(self, element: ET.Element, filepath: Path):
        """Write XML with proper formatting"""
        xml_str = ET.tostring(element, encoding='unicode')
        dom = minidom.parseString(xml_str)
        pretty_xml = dom.toprettyxml(indent='\t', encoding='UTF-8')

        with open(filepath, 'wb') as f:
            f.write(pretty_xml)

    def copy_event_from_template(self, template_event_id: str, new_name: str,
                                  dest_folder_id: str, bank_id: str, bus_id: str,
                                  audio_files: List[str], audio_asset_folder: str) -> str:
        """Copy an event from template (delegates to EventCreator)"""
        return EventCreator.copy_from_template(
            template_event_id, new_name, dest_folder_id, bank_id, bus_id,
            audio_files, audio_asset_folder, self.metadata_path,
            self.project_path, self.workspace
        )

    def create_audio_file(self, audio_file_path: str, asset_relative_path: str) -> str:
        """Create an AudioFile XML entry (delegates to AudioFileManager)"""
        return AudioFileManager.create(
            audio_file_path, asset_relative_path,
            self.metadata_path, self.workspace
        )
