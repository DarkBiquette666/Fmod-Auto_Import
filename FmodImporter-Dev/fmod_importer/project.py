"""
FMOD Project Management Module
Handles FMOD Studio project XML manipulation and metadata management.
"""

import os
import json
import uuid
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from xml.dom import minidom
import wave

from .core.xml_loader import XMLLoader
from .core.xml_writer import write_pretty_xml
from .core.pending_folder_manager import PendingFolderManager
from .core.bus_manager import BusManager
from .core.bank_manager import BankManager
from .core.event_folder_manager import EventFolderManager
from .core.asset_folder_manager import AssetFolderManager


class FMODProject:
    """Represents a FMOD Studio project and handles XML manipulation"""

    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
        self.metadata_path = self.project_path.parent / "Metadata"

        if not self.metadata_path.exists():
            raise ValueError(f"Metadata folder not found: {self.metadata_path}")

        # Initialize managers
        self._xml_loader = XMLLoader(self.metadata_path)
        self._pending_manager = PendingFolderManager()

        # Load only minimal data needed for UI at startup
        self.workspace = self._xml_loader.load_workspace()
        self.event_folders = self._xml_loader.load_event_folders()

        # OPTIMIZATION: Lazy load everything else
        self._banks = None
        self._buses = None
        self._asset_folders = None
        self._events_by_folder = None

    # CACHE LIKELY OBSOLETE - Remove if no performance issues
    # Code kept temporarily in case we notice slowdowns
    # def _load_from_cache(self):
    #     """Load project data from JSON cache (generated by FMOD Studio script)"""
    #     try:
    #         with open(self.cache_path, 'r', encoding='utf-8') as f:
    #             self._cache_data = json.load(f)
    #         self._cache_loaded = True
    #
    #         # Load workspace first
    #         self.workspace = self._load_workspace()
    #
    #         # Build event_folders from cache
    #         self.event_folders = {}
    #         for folder in self._cache_data.get('folders', []):
    #             self.event_folders[folder['id']] = {
    #                 'name': folder['name'],
    #                 'parent': folder['parent'],
    #                 'path': None,
    #                 'items': []
    #             }
    #
    #         # FALLBACK: If master folder is missing from cache, add it from workspace
    #         master_id = self.workspace.get('masterEventFolder')
    #         if master_id and master_id not in self.event_folders:
    #             # Load master folder from XML
    #             print(f"Warning: Master folder {master_id} not in cache, loading from XML...")
    #             xml_folders = self._load_event_folders()
    #             if master_id in xml_folders:
    #                 self.event_folders[master_id] = xml_folders[master_id]
    #             else:
    #                 print(f"Error: Master folder {master_id} not found in XML either!")
    #
    #         print(f"Loaded from cache: {len(self._cache_data.get('events', []))} events, {len(self.event_folders)} folders")
    #     except Exception as e:
    #         print(f"Cache load failed, falling back to XML: {e}")
    #         self._cache_loaded = False
    #         self.workspace = self._load_workspace()
    #         self.event_folders = self._load_event_folders()
    #
    # def has_cache(self) -> bool:
    #     """Check if cache file exists and was loaded successfully"""
    #     return self._cache_loaded

    @property
    def banks(self) -> Dict[str, Dict]:
        """Lazy load banks on first access"""
        if self._banks is None:
            self._banks = self._xml_loader.load_banks()
        return self._banks

    @property
    def buses(self) -> Dict[str, Dict]:
        """Lazy load buses on first access"""
        if self._buses is None:
            self._buses = self._xml_loader.load_buses()
        return self._buses

    @property
    def asset_folders(self) -> Dict[str, Dict]:
        """Lazy load asset folders on first access"""
        if self._asset_folders is None:
            self._asset_folders = self._xml_loader.load_asset_folders()
        return self._asset_folders

    def _load_workspace(self) -> Dict:
        """Load workspace.xml to get master folder references"""
        workspace_file = self.metadata_path / "Workspace.xml"
        if not workspace_file.exists():
            raise ValueError("Workspace.xml not found")

        tree = ET.parse(workspace_file)
        root = tree.getroot()

        workspace_obj = root.find(".//object[@class='Workspace']")
        if workspace_obj is None:
            raise ValueError("Workspace object not found")

        return {
            'id': workspace_obj.get('id'),
            'masterEventFolder': workspace_obj.find(".//relationship[@name='masterEventFolder']/destination").text,
            'masterBankFolder': workspace_obj.find(".//relationship[@name='masterBankFolder']/destination").text,
            'masterAssetFolder': workspace_obj.find(".//relationship[@name='masterAssetFolder']/destination").text
        }

    def _load_event_folders(self) -> Dict[str, Dict]:
        """Load all event folders from the EventFolder directory"""
        folders = {}
        event_folder_dir = self.metadata_path / "EventFolder"

        if not event_folder_dir.exists():
            return folders

        for xml_file in event_folder_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for obj in root.findall(".//object"):
                folder_id = obj.get('id')
                name_elem = obj.find(".//property[@name='name']/value")
                name = name_elem.text if name_elem is not None else "Unnamed"

                # Get parent folder
                parent_rel = obj.find(".//relationship[@name='folder']/destination")
                parent_id = parent_rel.text if parent_rel is not None else None

                folders[folder_id] = {
                    'name': name,
                    'parent': parent_id,
                    'path': xml_file,
                    'items': []
                }

        return folders

    def get_events_in_folder(self, folder_id: str) -> List[Dict]:
        """Get all events in a specific folder (delegates to EventFolderManager)"""
        return EventFolderManager.get_events_in_folder(
            folder_id, self.event_folders, self.metadata_path
        )

    def get_bus_from_template_events(self, folder_id: str) -> Tuple[Optional[str], bool, set]:
        """Analyze bus routing in template folder events (delegates to EventFolderManager)"""
        return EventFolderManager.get_bus_from_template_events(
            folder_id, self.event_folders, self.metadata_path
        )

    def _load_banks(self) -> Dict[str, Dict]:
        """Load all banks from the Bank directory"""
        banks = {}
        bank_dir = self.metadata_path / "Bank"

        if not bank_dir.exists():
            return banks

        for xml_file in bank_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            # Look for both MasterBank and Bank classes
            for obj in root.findall(".//object"):
                obj_class = obj.get('class')
                if obj_class in ['MasterBank', 'Bank']:
                    bank_id = obj.get('id')
                    name_elem = obj.find(".//property[@name='name']/value")
                    name = name_elem.text if name_elem is not None else "Unnamed"

                    # Get parent relationship if exists
                    parent_rel = obj.find(".//relationship[@name='folder']/destination")
                    parent_id = parent_rel.text if parent_rel is not None else None

                    banks[bank_id] = {
                        'name': name,
                        'path': xml_file,
                        'parent': parent_id
                    }

        return banks

    def _load_buses(self) -> Dict[str, Dict]:
        """Load all mixer buses from Master.xml and Group directory"""
        buses = {}

        # Load master bus from Master.xml
        master_file = self.metadata_path / "Master.xml"
        if master_file.exists():
            tree = ET.parse(master_file)
            root = tree.getroot()

            for obj in root.findall(".//object"):
                obj_class = obj.get('class')
                if obj_class == 'MixerMaster':
                    bus_id = obj.get('id')
                    name_elem = obj.find(".//property[@name='name']/value")
                    name = name_elem.text if name_elem is not None else "Master Bus"

                    buses[bus_id] = {
                        'name': name,
                        'path': master_file,
                        'parent': None  # Master has no parent
                    }

        # Load other buses from Group directory
        group_dir = self.metadata_path / "Group"
        if group_dir.exists():
            for xml_file in group_dir.glob("*.xml"):
                tree = ET.parse(xml_file)
                root = tree.getroot()

                for obj in root.findall(".//object"):
                    obj_class = obj.get('class')
                    if obj_class == 'MixerGroup':
                        bus_id = obj.get('id')
                        name_elem = obj.find(".//property[@name='name']/value")
                        name = name_elem.text if name_elem is not None else "Unnamed"

                        # Get parent relationship (output)
                        parent_rel = obj.find(".//relationship[@name='output']/destination")
                        parent_id = parent_rel.text if parent_rel is not None else None

                        buses[bus_id] = {
                            'name': name,
                            'path': xml_file,
                            'parent': parent_id
                        }

        return buses

    def _get_master_bus_id(self) -> Optional[str]:
        """Get the master bus ID (delegates to BusManager)"""
        return BusManager.get_master_bus_id(self.buses)

    def _load_asset_folders(self) -> Dict[str, Dict]:
        """Load all asset folders from the Asset directory"""
        asset_folders = {}
        asset_dir = self.metadata_path / "Asset"

        if not asset_dir.exists():
            return asset_folders

        for xml_file in asset_dir.glob("*.xml"):
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for obj in root.findall(".//object[@class='EncodableAsset']"):
                asset_id = obj.get('id')
                path_elem = obj.find(".//property[@name='assetPath']/value")
                asset_path = path_elem.text if path_elem is not None else ""

                master_folder_rel = obj.find(".//relationship[@name='masterAssetFolder']/destination")
                master_folder_id = master_folder_rel.text if master_folder_rel is not None else None

                asset_folders[asset_id] = {
                    'path': asset_path,
                    'xml_path': xml_file,
                    'master_folder': master_folder_id
                }

        return asset_folders

    def get_folder_hierarchy(self) -> List[Tuple[str, str, int]]:
        """Get event folders as a hierarchical list (delegates to EventFolderManager)"""
        master_id = self.workspace['masterEventFolder']
        return EventFolderManager.get_hierarchy(master_id, self.event_folders)

    def create_event_folder(self, name: str, parent_id: str, commit: bool = True) -> str:
        """Create a new event folder (delegates to EventFolderManager)"""
        return EventFolderManager.create(
            name, parent_id, commit, self.metadata_path,
            self.event_folders, self._pending_manager
        )

    def create_bank(self, name: str, parent_id: str = None) -> str:
        """Create a new bank folder (delegates to BankManager)"""
        return BankManager.create(name, parent_id, self.metadata_path, self.banks)

    def delete_bank(self, bank_id: str):
        """Delete a bank (delegates to BankManager)"""
        BankManager.delete(bank_id, self.banks, self.metadata_path)

    def create_asset_folder(self, name: str, parent_path: str, commit: bool = True) -> str:
        """Create a new asset folder (delegates to AssetFolderManager)"""
        return AssetFolderManager.create(
            name, parent_path, commit, self.metadata_path,
            self.asset_folders, self._pending_manager, self.workspace
        )

    def create_bus(self, name: str, parent_id: str = None) -> str:
        """Create a new bus (delegates to BusManager)"""
        # If no parent specified, route to Master Bus
        if not parent_id:
            parent_id = self._get_master_bus_id()
        return BusManager.create(name, parent_id, self.metadata_path, self.buses)

    def delete_bus(self, bus_id: str):
        """Delete a bus (delegates to BusManager)"""
        BusManager.delete(bus_id, self.buses, self.metadata_path)

    def delete_folder(self, folder_id: str):
        """Delete an event folder (delegates to EventFolderManager)"""
        EventFolderManager.delete(folder_id, self.event_folders, self.metadata_path)

    def commit_pending_folders(self) -> Tuple[int, int]:
        """
        Commit all pending folders to XML files (delegates to PendingFolderManager).

        Returns:
            Tuple of (num_event_folders_committed, num_asset_folders_committed)
        """
        return self._pending_manager.commit_all(
            self.event_folders,
            self.asset_folders,
            self.workspace,
            self.metadata_path
        )

    def clear_pending_folders(self) -> int:
        """
        Clear all pending folders without committing them (delegates to PendingFolderManager).

        Returns:
            Number of pending folders cleared
        """
        return self._pending_manager.clear_all()

    def get_all_event_folders(self) -> Dict[str, Dict]:
        """
        Get all event folders (both committed and pending).
        Useful for tree displays.
        """
        return self._pending_manager.get_all_event_folders(self.event_folders)

    def get_all_asset_folders(self) -> Dict[str, Dict]:
        """
        Get all asset folders (both committed and pending).
        Useful for tree displays.
        """
        return self._pending_manager.get_all_asset_folders(self.asset_folders)

    def is_folder_pending(self, folder_id: str) -> bool:
        """Check if a folder is pending (not yet committed to XML)"""
        return self._pending_manager.is_pending(folder_id)

    def _write_pretty_xml(self, element: ET.Element, filepath: Path):
        """Write XML with proper formatting"""
        xml_str = ET.tostring(element, encoding='unicode')
        dom = minidom.parseString(xml_str)
        pretty_xml = dom.toprettyxml(indent='\t', encoding='UTF-8')

        with open(filepath, 'wb') as f:
            f.write(pretty_xml)

    def copy_event_from_template(self, template_event_id: str, new_name: str,
                                  dest_folder_id: str, bank_id: str, bus_id: str,
                                  audio_files: List[str], audio_asset_folder: str) -> str:
        """
        Copy an event from template and assign audio files to it

        Args:
            template_event_id: ID of the template event to copy
            new_name: New name for the event
            dest_folder_id: Destination folder ID
            bank_id: Bank ID to assign
            bus_id: Bus ID to assign
            audio_files: List of audio file paths to assign
            audio_asset_folder: Folder where audio assets should be placed

        Returns:
            New event ID
        """
        import shutil

        # Find template event
        template_event_path = self.metadata_path / "Event" / f"{template_event_id}.xml"
        if not template_event_path.exists():
            raise ValueError(f"Template event {template_event_id} not found")

        # Parse template XML
        template_tree = ET.parse(template_event_path)
        template_root = template_tree.getroot()

        # Create new event ID
        new_event_id = "{" + str(uuid.uuid4()) + "}"

        # Deep copy the entire XML structure
        new_root = ET.Element('objects', serializationModel="Studio.02.02.00")

        # Map old IDs to new IDs
        id_map = {}

        # First pass: collect all IDs and create new ones
        for obj in template_root.findall(".//object"):
            old_id = obj.get('id')
            new_id = "{" + str(uuid.uuid4()) + "}"
            id_map[old_id] = new_id

        # Override the event ID with our chosen ID
        event_obj = template_root.find(".//object[@class='Event']")
        if event_obj is not None:
            id_map[event_obj.get('id')] = new_event_id

        # Second pass: copy objects and update references
        for obj in template_root.findall(".//object"):
            old_id = obj.get('id')
            new_obj = ET.SubElement(new_root, 'object')
            new_obj.set('class', obj.get('class'))
            new_obj.set('id', id_map[old_id])

            # Copy properties
            for prop in obj.findall('property'):
                new_prop = ET.SubElement(new_obj, 'property')
                new_prop.set('name', prop.get('name'))
                value_elem = prop.find('value')
                if value_elem is not None:
                    new_value = ET.SubElement(new_prop, 'value')
                    # Special case: replace event name
                    if obj.get('class') == 'Event' and prop.get('name') == 'name':
                        new_value.text = new_name
                    else:
                        new_value.text = value_elem.text

            # Copy relationships and update destinations
            for rel in obj.findall('relationship'):
                new_rel = ET.SubElement(new_obj, 'relationship')
                new_rel.set('name', rel.get('name'))

                # Special cases for relationships we want to override
                if obj.get('class') == 'Event':
                    if rel.get('name') == 'folder':
                        # Change to destination folder
                        dest = ET.SubElement(new_rel, 'destination')
                        dest.text = dest_folder_id
                        continue
                    elif rel.get('name') == 'banks':
                        # Change to selected bank
                        dest = ET.SubElement(new_rel, 'destination')
                        dest.text = bank_id
                        continue

                if obj.get('class') == 'MixerInput' and rel.get('name') == 'output':
                    # Change to selected bus
                    dest = ET.SubElement(new_rel, 'destination')
                    dest.text = bus_id
                    continue

                # Copy all destinations
                for dest_elem in rel.findall('destination'):
                    new_dest = ET.SubElement(new_rel, 'destination')
                    old_dest_id = dest_elem.text
                    # Update to new ID if it's in our map
                    new_dest.text = id_map.get(old_dest_id, old_dest_id)

        # Create audio files and add them to the event
        if audio_files:
            # Create AudioFile objects and SingleSound objects
            single_sound_ids = []

            for audio_file_path in audio_files:
                # Get the source audio file
                audio_file_src = Path(audio_file_path)

                # Create the FMOD asset path (relative to Assets folder)
                # Combine the asset folder path with the filename
                asset_relative_path = audio_asset_folder + audio_file_src.name

                # Copy audio file to FMOD project Assets folder
                assets_folder = self.project_path.parent / "Assets"
                dest_folder = assets_folder / Path(audio_asset_folder)
                dest_folder.mkdir(parents=True, exist_ok=True)

                dest_file = dest_folder / audio_file_src.name
                shutil.copy2(audio_file_src, dest_file)

                # Create AudioFile using the helper method
                # Pass the actual file path for reading properties, and the FMOD asset path
                audio_file_id = self.create_audio_file(str(audio_file_src), asset_relative_path)

                # Create SingleSound object
                single_sound_id = "{" + str(uuid.uuid4()) + "}"
                single_sound_obj = ET.SubElement(new_root, 'object', {'class': 'SingleSound', 'id': single_sound_id})

                # Add audioFile relationship
                rel_audio = ET.SubElement(single_sound_obj, 'relationship', name='audioFile')
                dest_audio = ET.SubElement(rel_audio, 'destination')
                dest_audio.text = audio_file_id

                single_sound_ids.append(single_sound_id)

            # Create MultiSound object
            multi_sound_id = "{" + str(uuid.uuid4()) + "}"
            multi_sound_obj = ET.SubElement(new_root, 'object', {'class': 'MultiSound', 'id': multi_sound_id})

            # Add length property (calculate from first audio file)
            try:
                with wave.open(audio_files[0], 'rb') as wav_file:
                    length_seconds = wav_file.getnframes() / float(wav_file.getframerate())
                    prop_ms_length = ET.SubElement(multi_sound_obj, 'property', name='length')
                    value_ms_length = ET.SubElement(prop_ms_length, 'value')
                    value_ms_length.text = str(length_seconds)
            except:
                # If we can't read the file, use a default length
                prop_ms_length = ET.SubElement(multi_sound_obj, 'property', name='length')
                value_ms_length = ET.SubElement(prop_ms_length, 'value')
                value_ms_length.text = "0.0"

            # Add sounds relationship
            rel_sounds = ET.SubElement(multi_sound_obj, 'relationship', name='sounds')
            for ss_id in single_sound_ids:
                dest_sound = ET.SubElement(rel_sounds, 'destination')
                dest_sound.text = ss_id

            # Find or create GroupTrack
            group_track = new_root.find(".//object[@class='GroupTrack']")
            if group_track is None:
                # Create a new GroupTrack if it doesn't exist
                group_track_id = "{" + str(uuid.uuid4()) + "}"
                group_track = ET.SubElement(new_root, 'object', {'class': 'GroupTrack', 'id': group_track_id})

                # Create EventMixerGroup for the track
                mixer_group_id = "{" + str(uuid.uuid4()) + "}"
                mixer_group = ET.SubElement(new_root, 'object', {'class': 'EventMixerGroup', 'id': mixer_group_id})

                # Add name property to mixer group
                prop_mg_name = ET.SubElement(mixer_group, 'property', name='name')
                value_mg_name = ET.SubElement(prop_mg_name, 'value')
                value_mg_name.text = "Audio 1"

                # Add effectChain to mixer group
                effect_chain_id = "{" + str(uuid.uuid4()) + "}"
                rel_effect_chain = ET.SubElement(mixer_group, 'relationship', name='effectChain')
                dest_effect_chain = ET.SubElement(rel_effect_chain, 'destination')
                dest_effect_chain.text = effect_chain_id

                # Add panner to mixer group
                panner_id = "{" + str(uuid.uuid4()) + "}"
                rel_panner = ET.SubElement(mixer_group, 'relationship', name='panner')
                dest_panner = ET.SubElement(rel_panner, 'destination')
                dest_panner.text = panner_id

                # Add output to EventMixerMaster
                event_mixer_master = new_root.find(".//object[@class='EventMixerMaster']")
                if event_mixer_master is not None:
                    rel_output = ET.SubElement(mixer_group, 'relationship', name='output')
                    dest_output = ET.SubElement(rel_output, 'destination')
                    dest_output.text = event_mixer_master.get('id')

                # Create effect chain
                effect_chain = ET.SubElement(new_root, 'object', {'class': 'MixerBusEffectChain', 'id': effect_chain_id})
                fader_id = "{" + str(uuid.uuid4()) + "}"
                rel_effects = ET.SubElement(effect_chain, 'relationship', name='effects')
                dest_fader = ET.SubElement(rel_effects, 'destination')
                dest_fader.text = fader_id

                # Create panner
                ET.SubElement(new_root, 'object', {'class': 'MixerBusPanner', 'id': panner_id})

                # Create fader
                ET.SubElement(new_root, 'object', {'class': 'MixerBusFader', 'id': fader_id})

                # Add mixerGroup relationship to GroupTrack
                rel_mixer = ET.SubElement(group_track, 'relationship', name='mixerGroup')
                dest_mixer = ET.SubElement(rel_mixer, 'destination')
                dest_mixer.text = mixer_group_id

                # Add GroupTrack to Event's groupTracks relationship
                event_obj = new_root.find(".//object[@class='Event']")
                if event_obj is not None:
                    rel_group_tracks = event_obj.find(".//relationship[@name='groupTracks']")
                    if rel_group_tracks is None:
                        rel_group_tracks = ET.SubElement(event_obj, 'relationship', name='groupTracks')
                    dest_group_track = ET.SubElement(rel_group_tracks, 'destination')
                    dest_group_track.text = group_track_id

            # Update GroupTrack to reference MultiSound
            rel_modules = group_track.find(".//relationship[@name='modules']")
            if rel_modules is None:
                rel_modules = ET.SubElement(group_track, 'relationship', name='modules')
            else:
                # Clear existing modules
                for dest in list(rel_modules.findall('destination')):
                    rel_modules.remove(dest)

            dest_module = ET.SubElement(rel_modules, 'destination')
            dest_module.text = multi_sound_id

            # Update Timeline to reference MultiSound
            timeline = new_root.find(".//object[@class='Timeline']")
            if timeline is not None:
                rel_timeline_modules = timeline.find(".//relationship[@name='modules']")
                if rel_timeline_modules is None:
                    rel_timeline_modules = ET.SubElement(timeline, 'relationship', name='modules')
                else:
                    # Clear existing modules
                    for dest in list(rel_timeline_modules.findall('destination')):
                        rel_timeline_modules.remove(dest)

                dest_timeline_module = ET.SubElement(rel_timeline_modules, 'destination')
                dest_timeline_module.text = multi_sound_id

        # Write new event file
        event_file = self.metadata_path / "Event" / f"{new_event_id}.xml"
        write_pretty_xml(new_root, event_file)

        return new_event_id

    def create_audio_file(self, audio_file_path: str, asset_relative_path: str) -> str:
        """
        Create an AudioFile XML entry in the FMOD project

        Args:
            audio_file_path: Full path to the source audio file
            asset_relative_path: Relative path within FMOD project (e.g., "Characters/Cat Boss Rich/Cat_Boss_Rich_Run_03.wav")

        Returns:
            The new AudioFile UUID
        """
        # Generate new UUID for AudioFile
        audio_file_id = "{" + str(uuid.uuid4()) + "}"

        # Read audio file properties
        try:
            with wave.open(audio_file_path, 'rb') as wav_file:
                # Get audio properties
                channel_count = wav_file.getnchannels()
                sample_rate = wav_file.getframerate()
                n_frames = wav_file.getnframes()

                # Calculate frequency in kHz
                frequency_khz = sample_rate / 1000.0

                # Calculate length in seconds
                length_seconds = n_frames / float(sample_rate)
        except Exception as e:
            raise ValueError(f"Failed to read audio file properties: {e}")

        # Create XML structure
        root = ET.Element('objects', serializationModel="Studio.02.02.00")
        obj = ET.SubElement(root, 'object', {'class': 'AudioFile', 'id': audio_file_id})

        # Add assetPath property
        prop_path = ET.SubElement(obj, 'property', name='assetPath')
        value_path = ET.SubElement(prop_path, 'value')
        value_path.text = asset_relative_path

        # Add frequencyInKHz property
        prop_freq = ET.SubElement(obj, 'property', name='frequencyInKHz')
        value_freq = ET.SubElement(prop_freq, 'value')
        value_freq.text = str(frequency_khz)

        # Add channelCount property
        prop_channels = ET.SubElement(obj, 'property', name='channelCount')
        value_channels = ET.SubElement(prop_channels, 'value')
        value_channels.text = str(channel_count)

        # Add length property
        prop_length = ET.SubElement(obj, 'property', name='length')
        value_length = ET.SubElement(prop_length, 'value')
        value_length.text = str(length_seconds)

        # Add masterAssetFolder relationship
        rel = ET.SubElement(obj, 'relationship', name='masterAssetFolder')
        dest = ET.SubElement(rel, 'destination')
        dest.text = self.workspace['masterAssetFolder']

        # Ensure AudioFile directory exists
        audio_file_dir = self.metadata_path / "AudioFile"
        audio_file_dir.mkdir(exist_ok=True)

        # Write XML to file
        audio_file_xml_path = audio_file_dir / f"{audio_file_id}.xml"
        write_pretty_xml(root, audio_file_xml_path)

        return audio_file_id
